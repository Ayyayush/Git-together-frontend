# ğŸš€ Lecture 3 â€“ Auth Persistence, Protected Routes & Security (Gittogether)

In this lecture, we solve a **real-world frontend problem** and introduce **proper security handling**.

The focus is on:
- Fixing logout-on-refresh issue
- Protecting routes
- Handling logout
- Adding profile page
- Making frontend behave like a real production app

---

## â— Problem Observed

Abhi ek major issue tha:

> Page refresh karte hi user **logout ho ja raha tha**

This is **NOT acceptable** in real applications.

User experience expectation:
- Login once
- Refresh page
- Still logged in

---

## ğŸ¤” Why Logout Was Happening on Refresh

Important understanding:

- Redux store is **in-memory**
- Page refresh â†’ Redux state resets
- Auth state was stored only in Redux
- Browser refresh clears frontend memory

But:
- JWT cookie was **still present**
- Backend still trusted the user

So issue was **frontend-side**, not backend.

---

## âœ… Correct Solution: Auth Persistence

Solution approach:
- Do NOT trust Redux on refresh
- Always verify auth from backend

Flow:
1. On app load
2ï¸2. Call backend endpoint to fetch logged-in user
3. If backend says user is valid â†’ restore Redux state
4. If not â†’ logout

This makes frontend **backend-driven**, not memory-driven.

---

## ğŸ” Auto-Login on Refresh

This concept is called:
- Session rehydration
- Auth persistence

Key idea:
> Browser refresh should not decide auth state  
> Backend should decide auth state

This is how real apps work (LinkedIn, Instagram, etc.).

---

## ğŸ§± Updating Body.jsx for Security

`Body.jsx` is used as a **layout + guard**.

Responsibilities:
- Check if user is logged in
- Allow access to protected routes only if authenticated
- Redirect unauthenticated users

Body becomes a **security gate**, not just a layout.

---

## ğŸ” Protected Routes

Requirement:
> Agar user login nahi hai, toh protected routes access nahi kar paana chahiye

Protected routes include:
- Feed
- Profile
- Requests

Unprotected routes:
- Login
- Signup

This ensures:
- No unauthorized access
- Clean security boundaries

---

## ğŸ›¡ï¸ Security Checks Added

Multiple checks are enforced:
- Backend validates JWT on every request
- Frontend validates auth on page load
- Routes are guarded
- UI reacts to auth state

Security is **layered**, not single-point.

---

## ğŸšª Logout Flow

Logout is handled properly:

Backend:
- Clears HTTP-only cookie

Frontend:
- Clears user state from Redux
- Redirects to login page
- UI updates automatically

Logout is now:
- Secure
- Predictable
- Consistent

---

## ğŸ‘¤ Profile Page

Profile page is introduced.

Purpose:
- Show userâ€™s personal details
- Prove that auth state is working
- Consume global user state

Profile page is:
- Protected
- Auth-dependent
- Backend-driven

---

## ğŸ§  Backend Thinking Applied to Frontend

- Redux store â†’ Cache, not source of truth
- Backend â†’ Final authority
- Refresh â†’ Re-verify session
- Layout â†’ Security gate
- Routes â†’ Access-controlled

Frontend is treated as a **secure client**, not a trusted one.

---

## ğŸ”¥ Interview-Level Explanation

> â€œRedux state resets on refresh, so I rehydrate auth by verifying the session from backend using cookies. Protected routes ensure unauthorized users canâ€™t access secure pages.â€

This answer shows **real-world experience**.

---

## âœ… Lecture 3 Summary

- Identified logout-on-refresh issue
- Understood why Redux state resets
- Implemented backend-driven auth check
- Updated Body.jsx as security guard
- Protected routes implemented
- Logout flow completed
- Profile page added
- Frontend security significantly improved

---

## ğŸš€ Whatâ€™s Next

Next lecture will focus on:
- Feed page integration
- Connection requests
- Real-time UI updates
- Pagination & performance

Frontend is now **secure, persistent, and production-ready**.

---
